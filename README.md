## Описание и цель 

В большом помещении (например, торговый центр) возле каждого входа и выхода есть устройство, которое считает и отдает 
информацию о количестве входящих и выходящих людей. Данное устройство интегрировано с нашим проектом и умеет передавать 
нам эти данные.

**Цель** - сделать вывод для клиентов информации о загрузке помещения

Пример для понимания - 
https://salsknews.ru/wp-content/uploads/2017/08/oooza969d01padjyjkt7bfsupkyor2i1lmc0fa6v.jpg
https://www.bibliotika.ru/system/images/412_medium.jpg

## ТЗ

1. Реализовать api для получения (сохранения в базе сайта) информации:
```
GET/POST /input?time=12333333&diff=-4
где time = unix timestamp события
diff - изменение. Положительное - зашло N человек, отрицательное - вышло N человек.

В ответ всегда возвращать {success: true}
```

Считаем, что с одним и тем же time может приходить несколько разных событий (из разных источников). 
Для каких-то time (секунд, минут, часов) изменения (запросы) могут отсутствовать.

Для удобства можно считать, что каждый следующий запрос имеет точно такой же или больший time.

Учитываем только запросы, приходящие с 10:00 по 22:00 (не включительно). Остальные запросы можно сохранять, 
но считать их в дневной/суточной загруженности не нужно. **Каждый день начинается 10:00 c нулевого количества посетителей.**

2. Реализовать api для вывода графиков:

GET /hours - почасовой график загрузки в течение дня
Нужно вернуть объект (php массив), где ключом является номер часа (10-21), а значением - строка low/medium/high, 
означающая среднюю загрузку помещения в течение суток по всем дням, имеющимся в базе.

GET /days - график загрузки по дням (числам) месяца
Нужно вернуть объект (php массив), где ключом является номер дня месяца (1-31), а значением - строка low/medium/high,
означающая среднюю загрузку помещения в течение дня (числа) месяца всем месяцам, имеющимся в базе.

Загрузка считается так:

На конец каждой **минуты** (XX:XX:59) фиксируется количество человек, находящихся в помещении.

Средняя загрузка часа считается как среднее арифметическое от 60 минутных загрузок (например, с 10:00 по 10:59 включительно) 
каждого дня (1, 2, 3...  января, февраля...) по которому есть информация.

Средняя загрузка дня считается как среднее арифметическое среди всех минутных загрузок в течение определенного дня (числа) месяца,
т.е. средней загрузки за 1 января, 1 февраля, 1 марта и т.д. по всем имеющимся данным.

````
Пример 19.03

time=1710806449 diff=10 // 10:00:49
time=1710806449 diff=-4 // 10:00:49
time=1710806452 diff=-4 // 10:00:52
time=1710806462 diff=3 // 10:01:02

На 10:00:00 (начало дня) у нас 0 посетителей в помещении
На 10:00:49 19.03 у нас 10-4 = 6 посетителей 
на 10:00:52 - 6-4 = 2 посетителя

на 10:01:03 = 2+3 = 5 посетителей

Больше других изменений за день нет вообще

итого:
на 10:00 = 2 посетителя (последнее состояние в этой минуте)
на 10:01 = 5 (последнее состояние в этой минуте)

Среднее по 10-11 часам 19.03 = (2 + 5*59)/60 = 4,95 (округляем до 5)
Среднее по 11-12 часам 19.03 = 5*60/60  = 5
и т.д. 

Среднее по дню 19.03 - 5*12 / 12 = 5
Среднее по дню 19.02 = 2
Среднее по дню 19.01 = 2

Среднее по 19 числу = 2+2+5 / 3 = 3

Среднее по 19.03 10-11 часов = 5
Среднее по 18.03 10-11 часов = 3
Среднее по 17.01 10-11 часов = 1

Среднее по 10-11 = 5+3+1/3 = 3
````

В выводе апи нужно вернуть загрузку относительно некоторой константы
- если средняя загрузка до 50% (включительно) от нее - low
- если от 50% до 80% - medium
- если больше 80% (включая все, что больше 100%) - high


## Не нужно делать

Фронтенд в любом виде (апи достаточно).

Кэширование в быстрое хранилище (memcache/redis). 

Не нужно хранить какие-то данные исключительно для "доработок и нового функционала" - описанное тз законченное, никакой 
новый функционал (например, таблицы и графики по каждому дню) не потребуются никогда.

Валидацию, проверку корректности данных.

## Как нужно делать

1. Склонировать / форкнуть проект на гитхабе
2. Установить php8.2 / 8.3
3. Установить MySQL 8+ (или MariaDB или postgresql, не принципиально)
4. В .env раскомментировать и заполнить данные для подключения к базе
5. Запустить php composer.phar install
6. Обдумать задачу
7. Сделать структуру базы через миграции или просто файлом .sql в корне проекта (без данных)
8. Не забыть подходящие индексы (если нужны)
9. Добавить функционал в контроллеры InputController (api сохранения данных). Данные "приходят" в методах $request. Поставить true в Response
10. Добавить функционал в методы контролера OutputController (апи для вывода) в Response в нужном (из примера) формате.
11. Если в задаче требуется что-то предрассчитать (с какой-то периодичностью) - можно создать консольную команду (пример TestCommand) php artisan make:command или методом CopyPaste из TestCommand. Команда запускается php artisan commandname
12. Запушить на github
13. Отправить ссылку

Для формирования запросов можно использовать чистый sql и методы ->select /selectOne / update / delete или querybuilder (не нужно использовать модели и orm).















